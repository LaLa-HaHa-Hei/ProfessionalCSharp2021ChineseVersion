\chapter{反射，元数据和源生成器}
\underline{\makebox[10cm][l]{这章中有什么？}}

\begin{itemize}
\item 使用自定义特性
\item 使用反射在运行时检查元数据
\item 使用dynamic类型
\item 用ExpandoObject创建动态对象
\item 用源生成器编译代码
\end{itemize}
\medskip
\underline{\makebox[10cm][l]{本章的代码下载}}

本章的源代码可在本书位于 \url{http://www.wiley.com} 的页面上获取。点击下载链接即可。
你也可以在 \url{https://github.com/ProfessionalCSharp/ProfessionalCSharp2021} 的 1\_CS/ReflectionAndSourceGenerators 目录下找到这些代码。
\\ \\
本章的代码分为以下几个主要示例：
\begin{itemize}
\item LookupWhatsNew
\item TypeView
\item VectorClass
\item WhatsNewAttributes
\item Dynamic
\item DynamicFileReader
\item CodeGenerationSample
\end{itemize}
所有的样例项目都启用了可空引用类型

\section{运行时代码检查和动态编程}
这章聚焦于自定义特性，反射，动态编程和借助C\#9源生成器在构建过程中的源代码生成。自定义特性是一些机制他允许你去联系自定义元数据和程序元素。这个元数据在编译的时候被创建，并且被嵌入到一个程序集。反射是一个通用术语，它描述了在运行时检查和操控程序元素这种能力。比如，反射允许你去做以下事情：
\begin{itemize}
\item 枚举一个类型中的成员
\item 实例化一个新对象
\item 执行一个对象中的成员
\item 找出一个类型的信息
\item 找出一个程序集的信息
\item 检查被应用到一个类型的自定义特性
\item 创建并编译一个新程序集
\end{itemize}
这个列表代表了很多的功能并且包含一些被.NET提供的最强大且最复杂的能力。因为一章中没有包含所有反射能力的空间，所以我聚焦于哪些你很可能去用的最频繁的元素。
\\ \\
为了去展示自定义特性和反射，在这章中，你将首先开发一个例子，基于一个频繁发布他的软件升级并且想要获得关于这些被自动记录的升级细节的公司。在这个例子中，你将定义指明程序元素被最后一次修改时的日期和被修改了什么的自定义特性。然后你使用反射开发一个程序，可以在一个程序集中寻找这些特性并且自动显示从给定日期开始的对软件升级的所有细节。
\\ \\
在这章中的另一个例子考虑了一个应用程序，它可以读出或写入一个数据库，并使用自定义特性标记哪些类或属性对应于哪些表或列。通过在运行时从程序集中读取这些特性，这个程序可以自动检索或写入数据到数据库中的恰当位置，而无需对于每个表或列编写特定逻辑。
\\ \\
这一章的第二个方面就是动态编程，自从dynamic类型被添加到C\#4，动态编程就成为C\#语言的一部分。虽然C\#是一个静态类型语言，但动态编程的加入给了C\#语言从C\#内部调用脚本函数的能力。
\\ \\
在本章中，你将了解dynamic类型及其使用规则。你还将看到DynamicObject的实现是什么样并且如何使用它。DynamicObject的实现之一ExpandoObject也将被涵盖。
\\ \\
本章的第三个大方面是一个C\#9的增强——源生成器。使用源生成器，代码可以在你开始构建流程是被生成。你写的源代码可以被增强，同时还可以利用其他数据源来生成C\#源代码。在本章中，你将看到源生成器检查特性，从而在编译时生成代码，而无需在运行时依赖反射。

\section{自定义特性}